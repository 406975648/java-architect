# JVM-GC

## GC(分代收集算法)

​		JVM在进行GC时，并非每次都对(年轻代、老年代、永久代)三个内存区域一起回收的，大部分时候回收的都是指新生代。

​		因此GC按照回收区域又分为两种类型：一种是普通GC(minor GC)，一种是全局GC(major GC or Full GC)

* 普通GC(minor GC): 只针对新生代区域的GC
* 全局GC(major GC or Full GC)：针对老年带的GC，偶尔伴随着对新生代的GC以及对永久代的GC

## GC的四大算法

### 引用计数法

	>缺点：

* 每次对对象赋值时都要维护引用计数器，且计数器本身也有一定的消耗；
* 较难处理循环引用

jvm的实现一般不采用这种方式

### 复制算法(Copy)

​		年轻代中的minor GC，主要是复制算法(Copying)		

​		Hotspot JVM把年轻带分为三个部分: 1个Eden和2个Survivor区(分别叫from和to)。默认比例为8：1：1，一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理)，这些对象讲过第一次Minor GC后，如果依然存储，将会被移到Survivor区。对象在Survivor区中每存活一次Minor GC,年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到老年代中。因为年轻带中的对象基本都是朝生夕死的(90%以上)，所以在年轻带的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为2块，每次只使用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

​		在GC开始的时候，对象只会存在与Eden区和名为From的survivor区，Survivor区To是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到To中，而在From区中依然存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到老年代中，没有达到阈值的对象会被复制到to区域。经过这次GC后，Eden区和From区以及被清空。这个时候，From和To会交换他们的角色，也就是新的to就是上次GC前的From，新的From就是上次GC前的to。不管怎样，都会保证名为to的survivor区域是空的。Minor GC会一直重复这样的过程，直到To区被填满，会将剩余对象移动到老年代中。

​		因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的Eden对象转移到10%的空闲空间，接下来，将之前90%的内存全部释放，以此类推。

> minor GC触发条件:

当Eden区域内存满后，会触发minor GC;

> 原理

​		从根集合(GC Root)开始，通过Tracing从From中找到存活对象，拷贝到To中

​		From、To交换身份、下次内存分配从To开始；

​		没有标记和清除的过程、效率高，但是需要两块内存、浪费内存

​		没有内存碎片，可以利用bump-the-pointer实现快速内存分配

> minor GC步骤

​		minor GC会把所有的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩余的活的对象就会被移到old generation中，也即一旦收集后，Eden是变成空的了。

​		当对象在Eden(包含一个Survivor区域，这里假设是form区域)出生后，在经过一次Minor GC后，如果对象还存活，并且能够被另外一块Survivor区域所容纳(上面已经假设为from区域，这里应为to区域，即to区域有足够的内存空间来存储eden和from区域中存活的对象)，则使用复制算法将这些依然还存活的对象复制到另外一块Survivor区域(即to区域)中，然后清理所使用的Eden以及Survivor区域(即from区域)，并且将这些对象的年龄设置为1，以后对象在Survivor区域每存活一次Minor GC,就将对象的年龄+1，当对象的年龄达到某个值时(默认是15岁，通过-XX:MaxTenuringThreshold来设定参数)，这些对象就会成为老年代。

-XX:MaxTenuringThreshold -- 设置对象在新生代中存活的次数

> 复制算法的缺点

		1. 它浪费了一半的内存
  		2. 如果对象存活率很高，我们可以极端一点100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。所以从以上描述不能看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且重要的是，我们必须要客服50%内存的浪费。



## JVM堆内存调优



> 相关调优参数

```java
-XX:+HeapDumpOnOutOfMemoryError: 该配置会把快照保存在用户目录或者tomcat目录下
-XX:HeapDumpPath=/tmp/heapdump.hprof: 显示指定dump文件路径
```



